/* NOTES

CSS is a declarative language for designing web pages

  BASIC

    selector {
      property: value;  <-- declaration
    } 

    Special inheritance values: inherit, initial, unset, revert

    Operators of interest to refer to elements:
      >   For direct child
      ~   For following sibling elements
      +   For just the next one
    
    Specifity levels (X, Y, Z):
      IDs >>> Classes, attributes and psudo-classes >>> Elements and pseudo-elements

    !important  <-- Important acts above specification levels but there may still be conflicts. Use as little as possible

    box-sizing: content-box   <-- Default
    box-sizing: border-box    <-- Margin and padding are incorporated into the size of the box

    overflow: visible   <-- Default
    overflow: hidden / scroll / auto

    text-overflow: clip       <-- Default
    text-overflow: ellipsis   <-- Adds ellipses to overflowing text

    position: static    <-- Default
    position: absolute  <-- We can determine the position coordinates of the element within the document
    position: relative  <-- Sets a reference to the parent element so that its children can be positioned absolutely within it
    position: fixed     <-- We can determine the position coordinates of the element within the viewport
    position: sticky    <-- It moves with the scroll but stays inside its parent element

    selector {
      inset: 0;
      margin: auto;   <-- To center elements. Not recommended
    }

    z-index   <-- Works within a stacking context

  
  FLEXBOX

    1D

    .container {
      display: flex;                  <-- Flexible container, allows us to have the children aligned in a more efficient 
                                          way both horizontally and vertically even having unknown or dynamic sizes
      flex-direction: row;            <-- Default
      flex-direction: column;         <-- Flex is unidirectional
      flex-direction: row-reverse;
      flex-direction: column-reverse;

      flex-direction: row;
      direction: rtl;                 <-- Right to left
      writing-mode: vertical-lr;      <-- Vertical left-right

      flex-wrap: nowrap;    <-- Default - If there is not enough space in the container, this makes it fit the contents
      flex-wrap: wrap;      <-- Gives the possibility that if the content does not fit in its container, it makes a line break

      flex-flow: row nowrap;    <-- Abbreviated joint form

      DISTRIBUTION ON THE MAIN AXIS

        justify-content: start    <-- Default
        justify-content: center / end / space-between / space-evenly / space-around 

      CROSS-AXLE DISTRIBUTION

        align-items: center;      <-- Items are aligned on the cross axis
        align-content: center;    <-- Aligns content on cross axis
        align-self: flex-start;   <-- Only the referenced element itself is aligned regardless of the properties of its parent

      MORE USED --> justify-content & align-items

      gap: 10px;  <-- Adds an amount of space between elements
    }

    .container div {
      flex: initial;      <-- Default values
        flex-grow: 0;         <-- Default - Elements do NOT grow
        flex-shrink: 1;       <-- Default - Elements can shrink to a size smaller than their flex-basis
        flex-basis: auto;     <-- Default - Elements have a base size in auto

      flex: auto;         <-- Content will automatically fit into the container
        flex-grow: 1;         
        flex-shrink: 1;       
        flex-basis: auto;

      flex: 1;            <-- All contained elements will have the same size
        flex-grow: 1;         
        flex-shrink: 1;       
        flex-basis: 0;
    }

    .container div:first-child {
      flex: 4;            <-- With the flex property: 1, it will take x4 of the size
      order: 3;           <-- Changes the order in which the elements are seen
    }

    .container div:nth-child(2) {
      flex: 2;            <-- With the flex property: 1, it will take x2 of the size
      order: 1;
    }

    .container div:last-child {
      flex: 1;            <-- Default - With the flex property: 1, it will take x1 of the size
      order: 3;
    }


  GRID

    2D

    .container {
      display: grid;

      grid-template-columns: 100px 100px 100px;   <-- Defines the number of columns and their size

      grid-template-columns: auto auto 20px;    <-- Auto defines column space based on available space and content

      grid-template-columns: 1fr;       <-- 1 column, 100% space
      grid-template-columns: 1fr 1fr;   <-- 2 columns, 50% space each one
      grid-template-columns: 2fr 3fr;   <-- 2 columns, 40% first column 60% second column

      grid-template-rows: 40px 20px 10px;   <-- Same but in rows

      grid-auto-rows: 100px;    <-- Every time rows are generated automatically, it does taking the indicated value

      grid-template-columns: repeat(3, 1fr)   <-- Repeats 3 times 1fr == 3 columns 1fr
      grid-auto-rows: repeat(2, 100px)        <-- Repeats 2 times 100px == 2 rows 100px

      grid-template-columns: 25px repeat(3, 1fr) 25px   <-- repeat() can be interspersed

      grid-template-columns: repeat(3, 25px 50px)     <-- This can also be done

      grid-template-columns: minmax(100px, 1fr) 1fr 1fr   <-- Min for first column will be 100px and max will be 1fr

      grid-column-gap: 10px;    <-- Separation between columns - Same as column-gap
      grid-row-gap: 20px;       <-- Separation between rows - Same as row-gap
      gap: 20px 10px;           <-- Shortcut for rows (first) and columns
      gap: 10px;                <-- Shortcut for rows and columns with same separation

      grid-template-columns: repeat(    <-- Responsive method
        auto-fill,                      <-- Locates the number of possible columns that meet the minmax requirement
        minmax(200px, 1fr)              <-- At least each column must occupy 200px
      );

      auto-fill   <-- Fill in the space with blank
      auto-fit    <-- Fill the space by adjusting the size of the elements

      DON'T CONFUSE ELEMENT SIZE WITH GRID SIZE

      justify-items: normal;      <-- Default - Aligns the elements inline inside the columns
      justify-items: stretch;     <-- Similar to default
      justify-items: start / center / end;

      align-items: normal / stretch / start / center / end;

      justify-content: start / center / end / space-between / ...;    <-- Aligns content

      align-content: start / center / end / space-between / ...;      <-- Aligns content

      place-content: start / center / end / space-between / ...;      <-- Shortcut to justify and align content
    }

    .container div:first-child {
      grid-column-start: 1;   <-- div starts at first column
      grid-column-end: 2;     <-- div ends at second column
      grid-row-start: 1;      <-- div starts at first row
      grid-row-end: 3;        <-- div ends at third row

      grid-column-start: span 2;    <-- Now we are telling it what we want it to occupy instead of how far it should go
      grid-row-start: span 2;       <-- Same but in rows

      grid-column: 2 / 4;   <-- Shortcut to indicate that it should go from column 2 to 4
      grid-row: 2 / 3;      <-- Shortcut to indicate that it should go from row 2 to 3

      grid-column: 4 / 5;   <-- Elements do not necessarily have to follow the html placement pattern
      grid-row: 1 / -2;     <-- We can use negative values too
      grid-column: 1 / -1;  <-- Frequently used to fill the entire row

      justify-self: normal / stretch / start / center / end   <-- Aligns the element itself inline inside the column

      align-self: normal / stretch / start / center / end;
    }

    .container div:nth-child(2)Â {
      grid-colum: 1 / 3;    <-- We can superimpose two elements in the same place without using absolute positions
      grid-row: 1/3;        <-- We can use z-index too
      opacity: -5;
    }

    HOW TO CREATE A TYPICAL LAYOUT USING GRID AREAS

      .container {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: 30px 1fr 100px;
        min-height: 100vh;
        grid-template-areas:        <-- Defines the design pattern
          "header header sidebar"
          "content content content"
          "footer footer footer";
      }

      @media (width > 400px) {    <-- We can also use media queries to change the design pattern
        .container {
          grid-template-areas:        
          "header header header"
          "sidebar content content"
          "footer footer footer";
      }

      .container header {
        background: blue;
        grid-area: header;    <-- Assigns a name to the area
      }

      .container aside {
        background: yellow;
        grid-area: sidebar;
      }

      .container main {
        background: red;
        grid-area: content;
      }

      .container footer {
        background: grey;
        grid-area: footer;
      }

      grid-template-areas:        
        "header header ."     <-- Dot is used to define an empty space
        "sidebar content content"
        "footer footer footer";
*/
